package VPNGui;
import java.io.*;
import java.net.*;
import java.security.*;
import javax.crypto.*;
import java.util.Random;
import java.math.BigInteger;
import javax.swing.text.DefaultCaret;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.DHParameterSpec;


/**
 * VPN Chat Interface
 * EECE 412
 * Programmed in NetBeans IDE
 * Author: Nicholas Bojanowski
 */
public class VPNGui extends javax.swing.JFrame implements Runnable {
    
    public final static VPNGui vpnObj = new VPNGui();
    
    // Thread Management
    public static boolean suspendFlag = false;
    
    // Prime Setup
    public static final BigInteger p = new BigInteger("179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007");
    public static final BigInteger g = new BigInteger("2");
    public static DHParameterSpec DHSpec = new DHParameterSpec(p, g);
    
    // DH Key Setup
    public static KeyPair keyPairAlice;
    public static KeyPair keyPairBob;
    public static KeyPairGenerator keyPairGenAlice;
    public static KeyPairGenerator keyPairGenBob;
    public static KeyAgreement keyAgree;
    public static PrivateKey privateAlice;
    public static PrivateKey privateBob;
    public static PublicKey publicAlice;
    public static PublicKey publicBob;
    public static SecretKey sharedSecretKey;
    public static byte[] keyBytesAlice;
    public static byte[] keyBytesBob;
    public static byte[] keyAsBytes;
    public static SecretKeyFactory keyFactory;
    public static DESedeKeySpec edeKeySpec;
      
    // Authentication
    public static String serverName;
    public static String clientName;
    public static SecretKey authSecretKey;
    public static byte[] authKeyBytes;
    public static String rAlice;
    public static String rBob;
    public static String secretVal = "secretVal";
    public static SecretKeyFactory authKeyFactory;
    public static DESedeKeySpec authKeySpec;
    public static String authEnc;
    public static String authDec;
    public static String authStringOut;
    public static String authStringIn;
    
    // Connection Display Info Constants
    public final static int NULL = 0;
    public final static int DISCONNECTED = 1;
    public final static int DISCONNECTING = 2;
    public final static int CONNECTING = 3;
    public final static int CONNECTED = 4;
    public final static int AUTHENTICATING = 5;
    public final static int KEYGEN = 6;
    public final static String connectionMessages[] = {"Could Not Connect.",
        "Disconnected", "Disconnecting...", "Connecting...", "Connected", "Authenticating...", "Generating Keys..."};    
    
    // Connection Stats
    public static String IPNum = "localhost";
    public static int portNum = 8000;
    public static int connectionStat = DISCONNECTED;
    public static boolean serverMode = true;
    public static boolean authMode = false;
   
    // String Management
    public static String connectingString = connectionMessages[DISCONNECTED];
    public static StringBuffer logString = new StringBuffer("");
    public static StringBuffer receivedString = new StringBuffer("");
    public static StringBuffer sendString = new StringBuffer("");
    public static StringBuffer sendEncString = new StringBuffer("");
    public final static String terminationCharacter = new Character
            ((char)0000).toString();
    public static String encString = "";
    public static String decString = "";
    
    // TCP Info
    public static ServerSocket server = null;
    public static Socket socket = null;
    public static BufferedReader incoming = null;
    public static PrintWriter outgoing = null;
    public static DataOutputStream outStreamDH = null;
    public static DataInputStream inStreamDH = null;    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        radioButtonServer = new javax.swing.JRadioButton();
        radioButtonClient = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        textFieldIP = new javax.swing.JTextField();
        textFieldPort = new javax.swing.JTextField();
        textFieldSecretVal = new javax.swing.JTextField();
        textFieldSent = new javax.swing.JTextField();
        buttonSend = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        textFieldReceived = new javax.swing.JTextArea();
        jSeparator1 = new javax.swing.JSeparator();
        buttonConnect = new javax.swing.JButton();
        buttonDisconnect = new javax.swing.JButton();
        jLabel6 = new javax.swing.JLabel();
        connectionStatusText = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        textFieldLog = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("VPN");

        jLabel1.setText("Server IP:");

        jLabel2.setText("Port:");

        buttonGroup.add(radioButtonServer);
        radioButtonServer.setSelected(true);
        radioButtonServer.setText("Server");
        radioButtonServer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioButtonServerActionPerformed(evt);
            }
        });

        buttonGroup.add(radioButtonClient);
        radioButtonClient.setText("Client");
        radioButtonClient.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioButtonClientActionPerformed(evt);
            }
        });

        jLabel3.setText("Shared Secret Value: ");

        jLabel4.setText("Data to be Sent:");

        textFieldIP.setText(IPNum);
        textFieldIP.setToolTipText("IP Address");
        textFieldIP.setEnabled(false);
        textFieldIP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textFieldIPActionPerformed(evt);
            }
        });

        textFieldPort.setText((new Integer(portNum).toString()));
        textFieldPort.setEnabled(false);
        textFieldPort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textFieldPortActionPerformed(evt);
            }
        });

        textFieldSecretVal.setText(secretVal);
        textFieldSecretVal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textFieldSecretValActionPerformed(evt);
            }
        });

        textFieldSent.setEnabled(false);
        textFieldSent.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textFieldSentActionPerformed(evt);
            }
        });

        buttonSend.setText("SEND");
        buttonSend.setEnabled(false);
        buttonSend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonSendActionPerformed(evt);
            }
        });

        jLabel5.setText("Data as Received:");

        jScrollPane1.setAutoscrolls(true);

        textFieldReceived.setEditable(false);
        textFieldReceived.setColumns(20);
        textFieldReceived.setRows(5);
        jScrollPane1.setViewportView(textFieldReceived);
        DefaultCaret caretIn = (DefaultCaret) textFieldReceived.getCaret();

        caretIn.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);

        buttonConnect.setText("Connect");
        buttonConnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonConnectActionPerformed(evt);
            }
        });

        buttonDisconnect.setText("Disconnect");
        buttonDisconnect.setEnabled(false);
        buttonDisconnect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonDisconnectActionPerformed(evt);
            }
        });

        jLabel6.setText("Connection Status:");

        connectionStatusText.setText(connectingString);

        textFieldLog.setEditable(false);
        textFieldLog.setColumns(20);
        textFieldLog.setRows(5);
        jScrollPane2.setViewportView(textFieldLog);
        DefaultCaret caretLog = (DefaultCaret) textFieldLog.getCaret();

        caretLog.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);

        jLabel7.setText("Event Log");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(textFieldSent)
                        .addGap(18, 18, 18)
                        .addComponent(buttonSend)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jSeparator1)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(buttonConnect, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(buttonDisconnect)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel6)
                        .addGap(18, 18, 18)
                        .addComponent(connectionStatusText)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1))
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel7)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(textFieldIP, javax.swing.GroupLayout.PREFERRED_SIZE, 204, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(16, 16, 16)
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(textFieldPort, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 75, Short.MAX_VALUE)
                                .addComponent(radioButtonServer)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(radioButtonClient))
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(textFieldSecretVal))
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel5)
                                    .addComponent(jLabel4))
                                .addGap(0, 0, Short.MAX_VALUE)))
                        .addGap(10, 10, 10))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2)
                    .addComponent(radioButtonServer)
                    .addComponent(textFieldIP, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(textFieldPort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(radioButtonClient))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(textFieldSecretVal, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonConnect)
                    .addComponent(buttonDisconnect)
                    .addComponent(jLabel6)
                    .addComponent(connectionStatusText))
                .addGap(16, 16, 16)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(textFieldSent, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonSend))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel5)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(8, 8, 8)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 295, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // If Server Radio Selected, set serverMode to true
    private void radioButtonServerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioButtonServerActionPerformed
        serverMode = true;
        changeStatus(NULL, true);
    }//GEN-LAST:event_radioButtonServerActionPerformed

    // Send the Contents of textFieldSent on button click
    private void buttonSendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonSendActionPerformed
        String s = textFieldSent.getText();
        
        // Add text to outgoing buffer
        if (!s.equals("")) {
            sendString.append(s);
            textFieldSent.setText("");
        }
    }//GEN-LAST:event_buttonSendActionPerformed

    // IP Address Text Field
    private void textFieldIPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textFieldIPActionPerformed
    }//GEN-LAST:event_textFieldIPActionPerformed

    // Port Text Field
    private void textFieldPortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textFieldPortActionPerformed
    }//GEN-LAST:event_textFieldPortActionPerformed

    // If Client Radio selected, set serverMode to false
    private void radioButtonClientActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioButtonClientActionPerformed
        serverMode = false;
        changeStatus(NULL, true); 
    }//GEN-LAST:event_radioButtonClientActionPerformed

    private void textFieldSecretValActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textFieldSecretValActionPerformed
    }//GEN-LAST:event_textFieldSecretValActionPerformed

    // Add inputted text to an String to be sent upon button press
    private void textFieldSentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textFieldSentActionPerformed
    }//GEN-LAST:event_textFieldSentActionPerformed

    // Connect the Client to the Server
    // Grab IP Socket Values and Apply them to Variables
    private void buttonConnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonConnectActionPerformed
        changeStatus(CONNECTING, true);
        
        secretVal = textFieldSecretVal.getText();
        IPNum = textFieldIP.getText();
        
        try {
            portNum = Integer.parseInt(textFieldPort.getText());
        }
        catch (NumberFormatException nfe) {
            textFieldPort.setText((new Integer(portNum).toString()));
        }
    }//GEN-LAST:event_buttonConnectActionPerformed

    // Disconnect the Client from the Server
    private void buttonDisconnectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonDisconnectActionPerformed
        changeStatus(DISCONNECTING, true);
    }//GEN-LAST:event_buttonDisconnectActionPerformed
  
    // Changing the Connection Status
    private static void changeStatus(int newStatus, boolean noError) {
        if (newStatus !=NULL) {
            connectionStat = newStatus;
        }
        
        if (noError) {
            connectingString = connectionMessages[connectionStat];
        }
        
        // If Error, Display Could Not Connect
        else {
            connectingString = connectionMessages[NULL];
        }
        
       vpnObj.run();
    }
    
    // Close open Sockets and Steam Buffers
    // Used upon a Disconnect
    private static void closeSockets(){
        // Try-Catch, so if Unable to Close, will default values to NULL
        // Try-Catch so an error won't break the shutdown cycle
        
        // Close Server
        try {
            if (server != null) {
                server.close();
                server = null;
            }
        } 
        catch (IOException ioe) {
            server = null;
        }
        
        // Close Socket
        try {
            if (socket != null) {
                socket.close();
                socket = null;
            }
        } 
        catch (IOException ioe) {
            socket = null;
        }
        
        // Close Incoming Buffers
        try {
            if (incoming != null) {
                incoming.close();
                incoming = null;
            }
            if (inStreamDH != null) {
                inStreamDH.close();
                inStreamDH = null;
            }
        } 
        catch (IOException ioe) {
            incoming = null;
            inStreamDH = null;
        }
        
        // Close Outgoing Buffers
        try {
            if (outgoing != null) {
                outgoing.close();
                outgoing = null;
            } 
            if (outStreamDH != null) {
                outStreamDH.close();
                outStreamDH = null;
            }
        }
        catch (IOException ioe) {
            outgoing = null;
            outStreamDH = null;
        }
    }
    
    // Runs After Socket Initialization
    // Mutually Authenticates Server-Client Connection
    public static void mutualAuth() throws Exception {      
        authMode = true;
        
        // Generate random number for auth
        Random rand = new Random();
        String s;
        
        // Create shared key keyAuth from shared secret value text field
        authKeyBytes = secretVal.getBytes("UTF8");
        
        // Hash with MD5, to create 256 bits of key material from input string
        // As DESedeKeySpec takes the first 192 bits for generation
        MessageDigest sha = MessageDigest.getInstance("SHA-256");
        byte[] hashBytes = sha.digest(authKeyBytes); 
        
        logString.append("\nShared Secret Key Generated from Shared Secret Value: \n");
                      
        // Create Key
        authKeySpec = new DESedeKeySpec(hashBytes);
        authKeyFactory = SecretKeyFactory.getInstance("DESede");
        authSecretKey = authKeyFactory.generateSecret(authKeySpec);
        
        logString.append(authSecretKey.toString()).append("\n\n");
        
        // Instantiate new Encryptor with shared secret auth key
        DES encryptorAuthDES = new DES(authSecretKey);
        
        // Set up Authentication                                
        if (serverMode)
        {
            // Set Own Name
            serverName = "Alice";
            // Set Name of Recipient;
            clientName = "Bob";
            // Generate Random Number for Alice
            rAlice = Integer.toString(rand.nextInt(999999999) + 1);

            // Send Greeting and Ra
            // @ Denotes greeting message, * delimits
            authStringOut = (("@Alice*")+ rAlice + "\n");
            outgoing.print(authStringOut);
            outgoing.flush();            
            
            logString.append("Message 1, Alice->Bob, Greeting and Challenge Sent: ").append(authStringOut).append("\n");
            
            // Receive Response
            s = incoming.readLine();

            logString.append("Message 2, Bob->Alice, Challenge and Response Received: ").append(s).append("\n");
            
            String[] splitString = s.split("[*]");            
            // Peel off the random number
            rBob = splitString[0];           
            // Decrypt the response
            
            // If Decryption fails, was encrypted with a different key
            try {
                authDec = encryptorAuthDES.decryptString(splitString[1]);
            }
            catch (BadPaddingException bpe)
            {
                logString.append("Authentication Failed in Client Response\n");
                logString.append("Could Not Decrypt, Shared Secret Values are not Equal\n");   
                changeStatus(DISCONNECTED, true);
            }
            
            logString.append("Response Decrypted: ").append(authDec).append("\n\n");
            logString.append("Bob has been Authenticated by Alice\n\n");
            // Check if message is from Bob, and if Decrypted rAlice is valid
            String[] splitString2 = authDec.split("[*]");
            if ((!splitString2[0].equals(clientName)) || (!splitString2[1].equals(rAlice))){
                logString.append("Authentication Failed in Client Response");
                changeStatus(DISCONNECTED, true);
            }
              
            // If Auth succeeded, send the final response
            else {
                // Prepare and Send Final Response
                authEnc = encryptorAuthDES.encryptString(serverName + "*" + rBob);
                authStringOut = (authEnc + "\n");
                outgoing.print(authStringOut);
                outgoing.flush(); 
            }
            
            logString.append("Message 3: Alice->Bob, Response Sent: ").append(authEnc).append("\n\n");
        }
        
        if (!serverMode)
        {
            // Set Own Name
            clientName = "Bob";
            // Generate Random Number for Bob
            rBob = Integer.toString(rand.nextInt(999999999) + 1);
            
            // Read First Message
            s = incoming.readLine();            
            
            logString.append("Message 1, Alice->Bob, Challenge Received: ").append(s).append("\n\n");
            
            // The incoming message is the initial handshake
            String[] splitString = s.split("[@*]");
            serverName = splitString[1];
            rAlice = splitString[2];
            
            // Prepare and Send Response
            authEnc = encryptorAuthDES.encryptString(clientName + "*" + rAlice);
            authStringOut = (rBob + "*" + authEnc + "\n");
            outgoing.print(authStringOut);
            outgoing.flush();

            logString.append("Message 2, Bob->Alice: Challenge and Response Sent: ").append(authStringOut).append("\n\n");
            
            // Recieve Final Message
            s = incoming.readLine();  
            logString.append("Message 3, Alice->Bob: Response Received: ").append(s).append("\n");
            
            // Decrypt the response
            authDec = encryptorAuthDES.decryptString(s);
            String[] splitString2 = authDec.split("[*]");           
            
            logString.append("Response Decrypted: ").append(authDec).append("\n");
            
            // Check if final message is from Alice, and if Decrypted rBob is valid
            if ((!splitString2[0].equals(serverName)) || (!splitString2[1].equals(rBob))){
                logString.append("Authentication Failed in Server Response");
                changeStatus(DISCONNECTING, true);
            }
            
            logString.append("Alice has been Authenticated by Bob\n\n");
        }
    }
    
    // Performs the Diffie-Hellman key exchange between Server and Client
    // Sets the value for variable sharedSecretKey
    public static void DHkeyGen() throws Exception {
        outStreamDH = new DataOutputStream(socket.getOutputStream());
        inStreamDH = new DataInputStream(socket.getInputStream());
        
        // Server is treated as Alice
        if (serverMode) {   
            // Initialize Alice's KeyPair
            logString.append("\nGenerate Alice's Private and Public Keys\n");
            keyPairGenAlice = KeyPairGenerator.getInstance("DH");
            keyPairGenAlice.initialize(DHSpec);
            keyPairAlice = keyPairGenAlice.generateKeyPair();           
            logString.append("Alice's Private and Public Keys Generated\n\n");
            
            // Send Public Key to Bob
            logString.append("Send Alice's Public Key to Bob\n");
            keyBytesAlice = keyPairAlice.getPublic().getEncoded();
            outStreamDH.writeInt(keyBytesAlice.length);
            outStreamDH.write(keyBytesAlice);
            logString.append("Alice's Key Sent to Bob: ").append(keyPairAlice.getPublic().toString()).append("\n\n");
            
            // Receive Public Key From Bob
            logString.append("Receive Public Key from Bob\n");
            keyBytesBob = new byte[inStreamDH.readInt()];
            inStreamDH.readFully(keyBytesBob);
            KeyFactory keyFacAlice = KeyFactory.getInstance("DH");
            X509EncodedKeySpec x509Bob = new X509EncodedKeySpec(keyBytesBob);
            publicBob = keyFacAlice.generatePublic(x509Bob);
            logString.append("Bob's Public Key Received: ").append(publicBob.toString()).append("\n\n");
            
            // Perform Key Agreement Using Alice's Private and Bob's Public Key
            logString.append("Calculate Shared Secret Key\n");
            keyAgree = KeyAgreement.getInstance("DH");
            keyAgree.init(keyPairAlice.getPrivate());
            keyAgree.doPhase(publicBob, true);  
        }
        
        // Client is treated as Bob
        else {
            // Initialize Bob's KeyPair
            logString.append("Generate Bob's Private and Public Keys\n");
            keyPairGenBob = KeyPairGenerator.getInstance("DH");
            keyPairGenBob.initialize(DHSpec);
            keyPairBob = keyPairGenBob.generateKeyPair();           
            logString.append("Bob's Private and Public Keys Generated\n\n");
            
            
            // Send Public Key to Alice
            logString.append("Send Bob's Public Key to Alice\n");
            keyBytesBob = keyPairBob.getPublic().getEncoded();
            outStreamDH.writeInt(keyBytesBob.length);
            outStreamDH.write(keyBytesBob);
            logString.append("Bob's Key Sent to Alice: ").append(keyPairBob.getPublic().toString()).append("\n\n");
            
            // Receive Public Key from Alice
            logString.append("Receive Public Key from Alice\n");
            keyBytesAlice = new byte[inStreamDH.readInt()];
            inStreamDH.readFully(keyBytesAlice);
            KeyFactory keyFacBob = KeyFactory.getInstance("DH");
            X509EncodedKeySpec x509Alice = new X509EncodedKeySpec(keyBytesAlice);
            publicAlice = keyFacBob.generatePublic(x509Alice);
            logString.append("Alices's Public Key Received: ").append(publicAlice.toString()).append("\n\n");
            
            // Perform Key Agreement Using Bob's Private and Alices's Public Key
            logString.append("Calculate Shared Secret Key\n");
            keyAgree = KeyAgreement.getInstance("DH");
            keyAgree.init(keyPairBob.getPrivate());
            keyAgree.doPhase(publicAlice, true);
        }
              
        // Create DES key from Bytecode
        keyAsBytes = keyAgree.generateSecret();
        keyFactory = SecretKeyFactory.getInstance("DESede");
        edeKeySpec = new DESedeKeySpec(keyAsBytes);
        sharedSecretKey = keyFactory.generateSecret(edeKeySpec);
        logString.append("Shared Secret Key Calculated: ").append(sharedSecretKey.toString()).append("\n\n");
    }
    
    // Run Method is called by "changeStatus()"
    // Run method is used to update the GUI depending on the current program state
    @Override
    public void run() { 
        
        switch (connectionStat) {
                
            case DISCONNECTED:
            buttonConnect.setEnabled(true);
            buttonDisconnect.setEnabled(false);
            textFieldIP.setEnabled(true);
            textFieldPort.setEnabled(true);
            radioButtonClient.setEnabled(true);
            radioButtonServer.setEnabled(true);
            textFieldSecretVal.setEnabled(true);
            textFieldSent.setEnabled(false);
            buttonSend.setEnabled(false);
            textFieldSent.setEnabled(false);
            connectingString = connectionMessages[DISCONNECTED];
            // Server Doesn't Need to Configure IP
            if (serverMode) {
                textFieldPort.setEnabled(false);
                textFieldIP.setEnabled(false);
            }  
            // Client Can Configure IP
            else {
                textFieldPort.setEnabled(true);
                textFieldIP.setEnabled(true);
            }
            break;            
                        
            case DISCONNECTING:
            buttonConnect.setEnabled(false);
            buttonDisconnect.setEnabled(false);
            textFieldIP.setEnabled(false);
            textFieldPort.setEnabled(false);
            radioButtonClient.setEnabled(false);
            radioButtonServer.setEnabled(false);
            textFieldSent.setEnabled(false);
            buttonSend.setEnabled(false);
            textFieldSent.setEnabled(false);
            textFieldSecretVal.setEnabled(false);
            connectingString = connectionMessages[DISCONNECTING];
            break;
                        
            case CONNECTED:
            buttonConnect.setEnabled(false);
            buttonDisconnect.setEnabled(true);
            textFieldIP.setEnabled(false);
            textFieldPort.setEnabled(false);
            radioButtonClient.setEnabled(false);
            radioButtonServer.setEnabled(false);
            textFieldSent.setEnabled(true);
            textFieldSecretVal.setEnabled(false);
            connectingString = connectionMessages[CONNECTED];
            buttonSend.setEnabled(true);
            textFieldSent.setEnabled(true);
            break;
                        
            case CONNECTING:
            buttonConnect.setEnabled(false);
            buttonDisconnect.setEnabled(false);
            textFieldIP.setEnabled(false);
            textFieldPort.setEnabled(false);
            radioButtonClient.setEnabled(false);
            radioButtonServer.setEnabled(false);
            textFieldSent.setEnabled(false);
            buttonSend.setEnabled(false);
            textFieldSent.setEnabled(false);
            textFieldSecretVal.setEnabled(false);
            connectingString = connectionMessages[CONNECTING];
            break;
                
            case AUTHENTICATING:
            connectingString = connectionMessages[AUTHENTICATING];
            break;
                
            case KEYGEN:
            connectingString = connectionMessages[KEYGEN];
            break;
        }
                
        // Match Frame States with Internal States
        radioButtonServer.setSelected(serverMode);
        connectionStatusText.setText(connectingString);
        textFieldReceived.append(receivedString.toString());
        receivedString.setLength(0);
        textFieldLog.append(logString.toString());
        logString.setLength(0);
    }
    
    public static void main(String args[]) throws Exception {        
        String s;
        String sTempEncr;
        String sTempDecr;      
                    
        // Initialize and Make Visible the GUI       
        vpnObj.initComponents();
        vpnObj.setVisible(true);
        
        // Depending the the Connection Status (Changed by pressing the GUI
        // buttons), set up servers or connect to server as a client.    
        while (true){
            // check every 15 ms for interruption
            try {
                Thread.sleep(15);
            }
            catch (InterruptedException ie) {}
            
            switch (connectionStat) {  
                
                case AUTHENTICATING:
                    // Set up Authentication                        
                    logString.append("Beginning Authentication\n");
                    mutualAuth();
                    logString.append("MUTUAL AUTHENTICATION\n\n");
                    changeStatus(KEYGEN,true);                      
                break;
                    
                case KEYGEN:     
                    // Generate the Shared Session Key
                    logString.append("Beginning Diffie-Helman Key Generation\n");
                    DHkeyGen();
                                        
                    logString.append("DH Key Sharing Complete\n\n");
                    logString.append("You are now connected, and ready to send text.\n");
                    changeStatus(CONNECTED,true);                   
                break;
                  
                // Set Up Server if in Server Mode
                // Connect to Server if in Client Mode
                case CONNECTING:
                    try {
                        // Set up Server
                        if(serverMode) {
                            server = new ServerSocket(portNum);
                            socket = server.accept();
                        }
                        
                        // Connect to Server, if Client
                        else {
                            socket = new Socket(IPNum, portNum);
                        }
                        
                        // Configure the Input and Output Buffers
                        incoming = new BufferedReader(new InputStreamReader
                                (socket.getInputStream()));
                        
                        outgoing = new PrintWriter(socket.getOutputStream(), true);
                        
                        // Changed State
                        changeStatus(AUTHENTICATING,true);
                    }
                    
                    catch (IOException ioe) {
                        // If Error, Return Error and Disconnect
                        changeStatus(DISCONNECTED, false);
                    }
                break;
                
                // Shut down currently established connection    
                case DISCONNECTING:
                    // Tell Connected Server/Client to disconnect also                 
                    outgoing.print(terminationCharacter);
                    outgoing.flush();
                    
                    // Change State and Close Connection
                    logString.append("Disconnected.\n");
                    changeStatus(DISCONNECTED, true);
                    closeSockets();                   
                break;
                    
                // If CONNECTED, Send Data from Client to Server    
                case CONNECTED:                    
                    // Initialize DES Class
                    DES encryptorDES = new DES(sharedSecretKey);
                    
                    try {
                        // Sending Data by checking the String Buffer
                        // filled by the SEND button
                        if (sendString.length() !=0) {
                            
                            // Buffer to String, Encrypt String, Send to Buffer
                            sTempEncr = encryptorDES.encryptString(sendString.toString());
                            sendEncString.append(sTempEncr).append("\n");
                            
                            // Update Log with Sent Text
                            logString.append("Encrypted Text Sent"
                                    + ": ").append(sTempEncr).append("\n");                           
                            
                            // Send the String Buffer
                            outgoing.print(sendEncString);
                            outgoing.flush();                          
                            sendString.setLength(0);
                            sendEncString.setLength(0);
                            
                            // Update the GUI
                            changeStatus(NULL, true);
                        }
                        
                        // Receiving Data
                        if (incoming.ready()) {
                            s = incoming.readLine();
                                    
                            // Check for Disconnection Signal
                            if (s.equals(terminationCharacter)) {
                                changeStatus(DISCONNECTING, true);
                            }
                            
                            // Fill incoming string buffer for appending to
                            // text box
                            else {                             
                                // Update Log with Recieved Text
                                logString.append("Encrypted Text Received"
                                    + ": ").append(s).append("\n");
                                
                                // Decrypt Incoming Text
                                sTempDecr = encryptorDES.decryptString(s);

                                receivedString.append(sTempDecr).append("\n");                                
                                // Update the GUI
                                changeStatus(NULL, true);
                            }
                        }
                    }
                    
                    catch (IOException ioe) {
                        closeSockets();
                        changeStatus(DISCONNECTED, false);
                    }
                break;
            }          
        }      
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonConnect;
    private javax.swing.JButton buttonDisconnect;
    private javax.swing.ButtonGroup buttonGroup;
    private javax.swing.JButton buttonSend;
    private javax.swing.JLabel connectionStatusText;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JRadioButton radioButtonClient;
    private javax.swing.JRadioButton radioButtonServer;
    private javax.swing.JTextField textFieldIP;
    private javax.swing.JTextArea textFieldLog;
    private javax.swing.JTextField textFieldPort;
    private javax.swing.JTextArea textFieldReceived;
    private javax.swing.JTextField textFieldSecretVal;
    private javax.swing.JTextField textFieldSent;
    // End of variables declaration//GEN-END:variables
}